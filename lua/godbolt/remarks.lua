-- Optimization remarks parser for YAML format
-- Parses LLVM optimization remarks from YAML files generated by -fsave-optimization-record

local M = {}

---@class RemarkLocation
---@field file string File path
---@field line number Line number
---@field column number Column number

---@class RemarkArg
---@field key string Argument key (e.g., "Callee", "Cost", "Threshold")
---@field value string Argument value

---@class Remark
---@field category "pass"|"missed"|"analysis" Category of remark
---@field message string What happened (e.g., "Inlined", "NotInlined")
---@field location RemarkLocation Source location
---@field function_name string|nil Function this remark is about
---@field pass_name string|nil LLVM pass name (e.g., "inline", "vectorize")
---@field args RemarkArg[]|nil Additional details
---@field extra table<string, string>|nil Other metadata fields

---@alias RemarksByPass table<string, Remark[]>

-- Parse YAML remarks file and return remarks grouped by pass name
---@param yaml_file string Path to YAML remarks file
---@return RemarksByPass Table of remarks grouped by pass name
function M.parse_remarks_yaml(yaml_file)
  if not yaml_file or vim.fn.filereadable(yaml_file) ~= 1 then
    return {}
  end

  local remarks_by_pass = {}
  local content = vim.fn.readfile(yaml_file)
  if not content or #content == 0 then
    return {}
  end

  -- Map YAML pass names to internal pass names
  -- LLVM outputs short names like "inline", "sroa", etc.
  -- We need to map them to full pass names like "InlinerPass", "SROAPass"
  local pass_name_map = {
    ["inline"] = "InlinerPass",
    ["sroa"] = "SROAPass",
    ["instcombine"] = "InstCombinePass",
    ["vectorize"] = "LoopVectorizePass",
    ["slp-vectorizer"] = "SLPVectorizerPass",
    ["loop-unroll"] = "LoopUnrollPass",
    ["licm"] = "LICMPass",
    ["gvn"] = "GVNPass",
    ["mem2reg"] = "PromotePass",
    ["dce"] = "DCEPass",
    ["adce"] = "ADCEPass",
    ["simplifycfg"] = "SimplifyCFGPass",
  }

  local current_record = {}
  local in_args = false
  local current_args = {}

  for _, line in ipairs(content) do
    -- YAML record separator
    if line:match("^%-%-%-") then
      -- Save previous record if complete
      if current_record.Pass and current_record.Name then
        local yaml_pass_name = current_record.Pass
        local pass_name = pass_name_map[yaml_pass_name]

        -- If not in map, capitalize first letter and add "Pass"
        if not pass_name then
          pass_name = yaml_pass_name:gsub("^%l", string.upper) .. "Pass"
        end

        if not remarks_by_pass[pass_name] then
          remarks_by_pass[pass_name] = {}
        end

        -- Determine category from record type
        local category = "pass"
        if current_record.Type == "Missed" then
          category = "missed"
        elseif current_record.Type == "Analysis" then
          category = "analysis"
        end

        table.insert(remarks_by_pass[pass_name], {
          category = category,
          message = current_record.Name,
          location = {
            file = current_record.File,
            line = current_record.Line,
            column = current_record.Column,
          },
          function_name = current_record.Function,
          pass_name = current_record.Pass,
          args = #current_args > 0 and current_args or nil,
          -- Store any extra fields we found
          extra = current_record.Extra,
        })
      end

      -- Start new record
      current_record = {}
      current_args = {}
      in_args = false

      -- Parse record type: "--- !Passed", "--- !Missed", "--- !Analysis"
      local record_type = line:match("^%-%-%-[%s]*!(%w+)")
      if record_type then
        current_record.Type = record_type
      end
    else
      -- Check if we're entering Args section
      if line:match("^Args:") then
        in_args = true
      elseif in_args and line:match("^%s+%-") then
        -- Parse Args list item: "  - String: 'value'" or "  - Callee: 'foo'"
        local arg_key, arg_value = line:match("^%s+%-%s+(%w+):%s*(.*)$")
        if arg_key and arg_value then
          arg_value = arg_value:gsub("^['\"]", ""):gsub("['\"]$", "")
          table.insert(current_args, {key = arg_key, value = arg_value})
        end
      elseif not line:match("^%s") then
        -- Left-aligned line means we're out of Args section
        in_args = false

        -- Parse key-value pairs: "Key: value"
        local key, value = line:match("^([%w]+):%s*(.*)$")
        if key and value then
          -- Remove quotes from value
          value = value:gsub("^['\"]", ""):gsub("['\"]$", "")

          if key == "Pass" then
            current_record.Pass = value
          elseif key == "Name" then
            current_record.Name = value
          elseif key == "Function" then
            current_record.Function = value
          elseif key == "DebugLoc" then
            -- Parse DebugLoc: { File: 'path', Line: 10, Column: 5 }
            local file = value:match("File: ([^,}]+)")
            local line_num = value:match("Line: (%d+)")
            local col = value:match("Column: (%d+)")

            if file then
              -- Remove quotes and whitespace
              current_record.File = file:gsub("^['\"%s]+", ""):gsub("['\"%s]+$", "")
            end
            if line_num then
              current_record.Line = tonumber(line_num)
            end
            if col then
              current_record.Column = tonumber(col)
            end
          else
            -- Store any other fields we don't explicitly handle
            if not current_record.Extra then
              current_record.Extra = {}
            end
            current_record.Extra[key] = value
          end
        end
      end
    end
  end

  -- Save last record if exists
  if current_record.Pass and current_record.Name then
    local yaml_pass_name = current_record.Pass
    local pass_name = pass_name_map[yaml_pass_name]

    if not pass_name then
      pass_name = yaml_pass_name:gsub("^%l", string.upper) .. "Pass"
    end

    if not remarks_by_pass[pass_name] then
      remarks_by_pass[pass_name] = {}
    end

    local category = "pass"
    if current_record.Type == "Missed" then
      category = "missed"
    elseif current_record.Type == "Analysis" then
      category = "analysis"
    end

    table.insert(remarks_by_pass[pass_name], {
      category = category,
      message = current_record.Name,
      location = {
        file = current_record.File,
        line = current_record.Line,
        column = current_record.Column,
      },
      function_name = current_record.Function,
      pass_name = current_record.Pass,
      args = #current_args > 0 and current_args or nil,
      extra = current_record.Extra,
    })
  end

  return remarks_by_pass
end

-- Match remarks to passes based on pass name and function
---@param passes table[] Array of pass tables from pipeline
---@param remarks_by_pass RemarksByPass Table from parse_remarks_yaml
---@return table[] Passes array with remarks attached
function M.attach_remarks_to_passes(passes, remarks_by_pass)
  if not passes or not remarks_by_pass then
    return passes
  end

  for _, pass in ipairs(passes) do
    -- Extract base pass name (before " on ") and target function/scope
    local base_name = pass.name:match("^(.+) on ") or pass.name
    local target_scope = pass.name:match(" on (.+)$")

    -- Check if we have remarks for this pass
    if remarks_by_pass[base_name] then
      -- Filter remarks to only those relevant to this specific pass instance
      local filtered_remarks = {}

      for _, remark in ipairs(remarks_by_pass[base_name]) do
        -- Include remark if:
        -- 1. No target scope (module-level pass), OR
        -- 2. Remark function_name matches target scope (function-level pass)
        -- 3. Target scope is in parentheses like "(foo)" for CGSCC passes
        local should_include = false

        if not target_scope then
          -- Module-level pass - include all remarks
          should_include = true
        elseif remark.function_name then
          -- Check if function_name matches the target
          -- Handle both "foo" and "(foo)" formats
          local clean_target = target_scope:gsub("^%((.+)%)$", "%1")  -- Remove parens
          clean_target = clean_target:gsub("^%[(.+)%]$", "%1")  -- Remove brackets for [module]

          if remark.function_name == clean_target then
            should_include = true
          end
        else
          -- No function_name in remark - might be module-level, include it
          should_include = true
        end

        if should_include then
          table.insert(filtered_remarks, remark)
        end
      end

      pass.remarks = filtered_remarks
    else
      pass.remarks = {}
    end
  end

  return passes
end

-- Generate remarks file path for a compilation
---@param source_file string Path to source file being compiled
---@return string Path to remarks YAML file
function M.get_remarks_file_path(source_file)
  -- Use temp directory to avoid cluttering project
  local temp_dir = vim.fn.tempname()
  vim.fn.mkdir(temp_dir, "p")

  -- Generate unique name based on source file and PID
  local basename = vim.fn.fnamemodify(source_file, ":t:r")
  local pid = vim.fn.getpid()
  local remarks_file = string.format("%s/%s-remarks-%d.yaml", temp_dir, basename, pid)

  return remarks_file
end

-- Clean up remarks file after parsing
---@param remarks_file string Path to YAML file to delete
function M.cleanup_remarks_file(remarks_file)
  if remarks_file and vim.fn.filereadable(remarks_file) == 1 then
    vim.fn.delete(remarks_file)

    -- Try to remove parent directory if empty
    local parent = vim.fn.fnamemodify(remarks_file, ":h")
    pcall(vim.fn.delete, parent, "d")
  end
end

return M
